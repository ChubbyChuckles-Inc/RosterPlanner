Overview:
You are assisting in implementing a maintainable PyQt6-based GUI for RosterPlanner, a match planning program for roster management.
The focus is on maintainability: Write clean, modular code with clear separation of concerns (e.g., use MVC patterns where appropriate: views, viewmodels, models/repositories).
Follow PEP 8 style guidelines, use type hints (from typing import ...), and include docstrings for all classes, methods, and functions.
Structure the project with a dedicated GUI package (e.g., gui/app, gui/views, gui/viewmodels, gui/components, gui/services) as outlined in Milestone 1.1.
Prioritize testability: For each new feature or component, add unit tests (using unittest or pytest) for core logic, and consider integration tests for GUI elements where feasible.
Use dependency injection or service locators for loose coupling (reference Milestone 1.4).
Handle errors gracefully with logging and user-friendly messages.
Incorporate version control best practices: Commit small, atomic changes with descriptive messages.
Document architectural decisions inline or in separate ADR files as per Milestone 14.6.
Ensure scalability: Design for future extensions like plugins (Milestone 12) and performance optimizations (Milestone P).
Reuse existing implemented baseline features (e.g., modular scraping pipeline, TrackingState) without duplication.

Implementation Roadmap:
Read the full TODO list from "roadmaps/implementation_GUI.txt". Tasks marked [x] are already implementedâ€”build upon them.
Proceed sequentially: Start with the next unfinished task in the current milestone (beginning with Milestone 0), then move to sub-tasks or the next milestone. Handle cross-cutting sections (e.g., Research, Documentation, Performance) when they become relevant or unblocked.
For the current task:Identify the next unfinished task by scanning the file from top to bottom.
If it's blocked ([>]), suggest how to unblock it or an alternative path.
When faced with decisions or options (e.g., choice of libraries, approaches), autonomously choose the most straightforward, maintainable option that aligns with guidelines (prefer minimal dependencies, Qt-native where possible, high performance), and explain your choice briefly in the response. Do not ask for user input unless the task is explicitly marked [!] (requires user decision).
Implement in small, testable chunks: Suggest code for one logical step at a time (e.g., define a class, then add methods, then tests).
For research tasks ([R]), provide a short spike (e.g., code experiment or analysis) and recommend a decision.
For documentation tasks ([D]), suggest the content or file updates.
For testing tasks ([T]), suggest the test code.
After suggesting implementation for a task (or chunk), include:An updated snippet of the roadmap with the task marked [x] (or [~] if partial), so I can copy-paste it back into "roadmaps/implementation_GUI.txt".
A professional commit message (e.g., "feat: implement design tokens for color roles") to append to ".pending-commits.txt".

After completing all tasks in a milestone, suggest running tests, demoing the feature, and any relevant metrics checks.
If the entire roadmap is complete, state so and suggest next steps like release preparation.

Now, read "roadmaps/implementation_GUI.txt", identify the next unfinished task, and proceed with implementation suggestions.

